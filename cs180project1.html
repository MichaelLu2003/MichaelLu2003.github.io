<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS180 Project 1</title>
</head>
<body>
    <h1>Maochuan Lu - CS180 Project 1</h1>
    <h2>What I do? </h2>
    <p style="font-size: 14px;">
    In this project, we aim to align RGB channels to produce color images. Here is my code documentation and idea: 1. To align channels, we definitely need to move or shift a channel based on xy-displacement.
    In this case, we create helper function shift(pic, x, y) using np.roll. 
    2. We also need a metric to evaluate whether this shift can give us better alignment. I choose normalized cross correlation for this metric which is more robust to brightness.
    3. With ncc and shift, we begin to implement our naive align function, which simply compare each possible shift in a window, and return the best shift with best ncc score.
    4. However, with naive alignment function, processing large pictures is quite slow. So we implement pyramid alignment funciton using recursion (iterative one is quite slow). Here is the idea of it,
        Firstly, we get our base case (level == 0), and simply return naive alignment in the final layer.
        Secondly, For other levels, we scale down pictures by a factor of 2 creating a pyramid of images at lower resolutions. Then it recursivelycalls calls pyramid_align to images at the next level.
        Here is the punchline, After finding the best alignment at a lower resolution, we scale the current best alignment offsets by a factor of 2, since the previous level was downscaled by factor of 2.
        Then we shifts pic1 based on these scaled offsets and refines the alignment by performing a final alignment at the current level using the align function.
    5. When finish implemneting above function, our alignment for simple pictures like cathedral.jpg looks great, but for images like emir.tif, it still not good.
    6. So, after I check the ed, classmate gives the idea that using feature.canny and cropping will be helpful, so I begin to search what is canny and how to use it through google. 
    7. Then i begin to implement manual_crop function, which simply scale down heigh and width by fixed percent, like 15% to remove borders.
    8. Finally, using the skeleton code to align channels processed by canny, and get their shifted coordinates, and using these coordinates back to the original image, and shift them to get a full image.
    9. It works really well for all of images! 
    </p>
    <h2>Results</h2>
    <img src="./proj1_pic/out_pic/out_cathedral.jpg" width="500"> <br/>
    cathedral.jpg <br/>
    <br/>
    <img src="./proj1_pic/out_pic/out_church.jpg" width="500"> <br/>
    church.tif <br/>
    <br/>
    <img src="./proj1_pic/out_pic/out_emir.jpg" width="500"> <br/>
    emir.tif <br/>
    <br/>
    <img src="./proj1_pic/out_pic/out_harvesters.jpg" width="500"> <br/>
    harvesters.tif <br/>
    <br/>
    <img src="./proj1_pic/out_pic/out_icon.jpg" width="500"> <br/>
    icon.tif <br/>
    <br/>
    <img src="./proj1_pic/out_pic/out_lady.jpg" width="500"> <br/>
    lady.tif <br/>
    <br/>
    <img src="./proj1_pic/out_pic/out_melons.jpg" width="500"> <br/>
    melons.tif <br/>
    <br/>
    <img src="./proj1_pic/out_pic/out_monastery.jpg" width="500"> <br/>
    monastery.jpg <br/>
    <br/>
    <img src="./proj1_pic/out_pic/out_sculpture.jpg" width="500"> <br/>
    sculpture.tif <br/>
    <br/>
    <img src="./proj1_pic/out_pic/out_self_portrait.jpg" width="500"> <br/>
    self_portrait.tif <br/>
    <br/>
    <img src="./proj1_pic/out_pic/out_three_generations.jpg" width="500"> <br/>
    three_generations.tif <br/>
    <br/>
    <img src="./proj1_pic/out_pic/out_tobolsk.jpg" width="500"> <br/>
    tobolsk.jpg <br/>
    <br/>
    <img src="./proj1_pic/out_pic/out_train.jpg" width="500"> <br/>
    train.tif <br/>
    <a href="cs180.html">Back to CS180 Projects</a>
</body>
</html>

