<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS180 Final Project</title>
</head>
<body>
    <h1>Maochuan Lu - Project 1 Gradient Domain Fusion</h1>

    <h2 style="font-size: 30px;">Overview</h2>
    <p style="font-size: 20px;">
        In this project, we are going to implement Poisson Blending and Mixed Gradient in Bells & Whistles to seamlessly blend an object or texture from a source image into a target image.
    </p>

    <h2 style="font-size: 30px;">Part 1 Toy Problem</h2>
    <p style="font-size: 20px;">
      In this part, I reconstruct a toy image from its gradients by solving a sparse linear system using least squares. 
      The process is same as the implementation details: I firstly try to map each pixel to a variable index and then I define a sparse matrix <code>A</code> and  
        <code>b</code>, which represent the x-gradients and y-gradients of the image. Additionally, I add a constriant for the top-left pixel to anchor the 
        reconstruction. The system <code>Av = b</code> is then solved using the <code>lsqr</code> method, and 
        the solution <code>v</code>. Here is my result: 
    </p>
    <img src="./final_project/gradient_domain/part1.png" width="600" alt="part1.png"> <br/>

    <h2 style="font-size: 30px;">Part 2 Poisson Blending</h2>
    <p>
        In this part, I implement poisson blending, which is a wonderful technique that merges an object image
        into a background image seamlessly through gradient trick. 
    </p>
    <p>
        The problem can be formulated as a minimization problem:
    </p>
    <div class="math">
        Minimize: 
        <br>
        <code>
            \[ \sum_{(x, y) \in \text{mask}} \| \nabla v(x, y) - \nabla \text{object}(x, y) \|^2 \]
        </code>
        <br>
        Subject to: 
        <br>
        <code>
            v(x, y) = \text{background}(x, y) \quad \forall (x, y) \in \text{boundary}.
        </code>
    </div>
    <ol>
        <li>
            <strong>Setup:</strong> Initializes variables for the object image, mask, and background image. 
            Each pixel in the mask is mapped to a variable, and neighboring relationships are represented 
            in a sparse matrix <code>A</code> and vector <code>b</code>.
        </li>
        <li>
            <strong>Gradient Constraints:</strong> For each pixel in the mask:
            <ul>
                <li>If the neighbor is inside the mask, the gradient from the object image is preserved.</li>
                <li>If the neighbor is outside the mask, the gradient is aligned with the background image.</li>
            </ul>
        </li>
        <li>
            <strong>Least Squares Solution:</strong> Solves the sparse linear system <code>Av = b</code> 
            using <code>lsqr</code>, where <code>v</code> contains the reconstructed pixel intensities.
        </li>
        <li>
            <strong>Blend and Return:</strong> Updates the pixels in the blended region and returns 
            the output image, seamlessly integrating the object into the background.
        </li>
    </ol>
    
    <img src="./proj3_pic/Part2.png" width="800" alt="Part2.png"> <br/>








    
    <h2 style="font-size: 30px;">Project 2 Poor Man's Augmented Reality</h2>
    <p style="font-size: 20px;">
        In Part 2, I created a GIF morph sequence with 45 frames, each with a duration of 30 ms. Since the GIF file was too large to upload to GitHub, I converted it into a YouTube video. You can watch it directly below:
    </p>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/ZCOOzz04D_g" 
        title="YouTube video player" frameborder="0" 
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
        allowfullscreen></iframe>

</body>
</html>
